# -*- coding: utf-8 -*-
"""NOTES 02.03 - PYTHON NUMPY.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/rramosp/ai4eng.v1/blob/main/content/NOTES%2002.03%20-%20PYTHON%20NUMPY.ipynb

# 02.03 - NUMPY
"""

!wget --no-cache -O init.py -q https://raw.githubusercontent.com/rramosp/ai4eng.v1/main/content/init.py
import init; init.init(force_download=False); init.get_weblink()

import numpy as np

"""## `numpy` is mostly about matrix data manipulation

see this cheat sheet: https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Numpy_Python_Cheat_Sheet.pdf

Python **lists** do not implement matrix semantics
"""

a = [ 1, 2, 3]
b = [10,20,30]
a + b

a = np.array([1,2,3])
b = np.array([10,20,30])
a + b

"""## Many ways of creating arrays"""

# manually
a = np.array([[1,2,3],[4,5,6]])
a

# random creation
a = np.random.random(size=(3,5))
a

a = np.random.normal(size=(2,3,4))
a

a = np.random.randint(100, size=(4,10))
a

# deterministic
np.eye(3)

np.linspace(-3,20,10)

np.arange(-3,20)

np.arange(-3,2)

np.zeros((5,10))

np.ones((5,10))

"""## Info on arrays"""

a = np.random.randint(100, size=(3,4))
a

a.shape, len(a)

len(a.shape)

a.size

a.dtype

b = a.astype(np.float32)
b

"""## Operations with arrays

**element by element**
"""

a = np.array([3,5,4])
b = np.array([10,5,30])

a + b

a * b

b ** a

np.sin(a)

a == b

"""**matrix operations**"""

a.sum()

np.sum(a), np.max(a), np.min(a), np.mean(a), np.std(a), np.product(a)

a.dot(b)

np.sum(a*b)

a = np.random.randint(100, size=(3,4))
a

a.T

a = np.array([3,5,4])
b = np.array([10,5,30])

np.allclose(a,b)

np.any(a==b)

"""## Indexing

"""

a = np.random.randint(100, size=(6,10))
a

a[1]

a[:,1]

a[1,:]

a[:3]

a[:,3:8]

a[2:-1,3:-2]

"""boolean indices"""

a = np.random.randint(100, size=(10))
a

a[[ True,  True, False, False, False, False,  True, False, False, False]]

a<50

a[a<50]

a[(a<50)&(a%2==0)]



"""## Axis operations"""

a = np.random.randint(100, size=(6,10))
a

np.max(a, axis=0)

np.max(a, axis=1)

np.mean(a, axis=1)

np.argmax(a, axis=1)

"""**reshaping is very useful**"""

a.shape

a.reshape(5,12)

a.reshape(5,-1)

"""## Many things can be represented by matrices. For instance, images"""

# Commented out IPython magic to ensure Python compatibility.
from skimage import io
import matplotlib.pyplot as plt
# %matplotlib inline

img = io.imread("local/imgs/sample_img.jpg")
type(img)

img.shape

np.min(img), np.max(img)

"""convert it to standard [0,1] range"""

img = img/255

np.min(img), np.max(img)

plt.imshow(img)

"""observe the channel composition of the image: lighter $\rightarrow$ greater color presence"""

cnames = ["red", "green", "blue"]
plt.figure(figsize=(20,4))
for i in range(3):
    plt.subplot(1,3,i+1)
    plt.imshow(img[:,:,i], plt.cm.Greys_r)
    plt.title("channel %i: %s"%(i, cnames[i]))

"""grayscale version"""

plt.imshow(np.mean(img, axis=2), plt.cm.Greys_r)

plt.imshow(img[:img.shape[0]//2,:,:])

plt.imshow(img[:,img.shape[1]//2:,:])

plt.imshow(img[90:220, 150:330,:])

"""**copy an array**"""

img2 = img.copy()
id(img), id(img2)

"""increase luminosity"""

img2[90:220, 150:330,:] *= 2
plt.imshow(img2)

"""remove channel"""

img2[30:120, 280:, 0] = 0
plt.imshow(img2)

plt.imshow(img[::-1,:,:])

"""understand luminosity on each channel"""

img.flatten().shape

img[:,:,0].flatten().shape

cnames = ["red", "green", "blue"]
plt.figure(figsize=(20,4))
for i in range(3):
    plt.subplot(1,3,i+1)
    plt.hist(img[:,:,i].flatten(), bins=20);
    plt.title("channel %i: %s"%(i, cnames[i]))

"""reduce luminosity on red channel"""

img3 = img.copy()
img3[:,:,0][img3[:,:,0]>0.8] = 0.5
plt.hist(img3[:,:,0].flatten(), bins=20);

plt.figure(figsize=(15,4))
plt.subplot(121); plt.imshow(img); plt.title("original")
plt.subplot(122); plt.imshow(img3); plt.title("red reduced")

"""shift and overlap"""

img4 = (img[5:,:,:] + img[:-5:,:,:])/2
plt.imshow(img4)

img3.shape, img.shape

"""## Vectorization

exploit `numpy` vectorized operations, avoid **for** loops as much as possible
"""

a = np.random.randint(100, size=(6,10))
a

np.mean(a, axis=1)

np.array([np.mean(a[i,:]) for i in range(a.shape[0])])

# Commented out IPython magic to ensure Python compatibility.
# %timeit np.mean(a, axis=1)

# Commented out IPython magic to ensure Python compatibility.
# %timeit np.array([np.mean(a[i,:]) for i in range(a.shape[0])])

"""always think if oyu can vectorize. For instance, for two (**large**) matrices"""

a = np.random.randint(100, size=(1000,100))
b = np.random.randint(200, size=(1000,100))

"""the number of elements which are the equal"""

np.mean(a==b)

"""The mean of the elements of `a` that are greater to its corresponding position in `b`"""

np.mean(a[a>b])

"""The mean of the elements of `b` that are greater to its corresponding position in `a`

"""

np.mean(b[b>a])

"""with smaller matrices"""

a = np.random.randint(100, size=(10))
b = np.random.randint(200, size=(10))
print (a)
print (b)

"""the element in `b` corresponding to the position of the greatest element in `a`"""

b[np.argmax(a)]

"""## Broadcasting

usually `numpy` needs matrix dimensions to match when doing operations among them
"""

a = np.random.randint(100, size=(3,5))
b = np.random.randint(10, size=(3,4))
print (a)
print (b)
a + b

"""but `numpy` _tries_ to expand the operations if some dimensions match"""

a

a*10

"""observe the `reshape` in the following operation"""

a + b[:,1].reshape(-1,1)

b[:,1].reshape(-1,1)

b[:,1]

a + b[:,1]

"""observe row wise"""

a + b.flatten()[:a.shape[1]]

print (a)
print (b)

b.flatten()

b.flatten()[:a.shape[1]]

"""## Functions args by reference

except scalar, function arguments are always passed **by reference**

- if you modify it within a function it will change
- the name within a function can be different, but will point to the same object

observe the difference if the following expressions (showing with `numpy` arrays, not general in python)
"""

a = np.round(np.random.random(size=5),3)
print (a)
id(a)

a = a + 1
print (a)
id(a)

"""this operation is semantically the same, but it produces a different memory footprint (faster, no copy, modifies in place)"""

a += 1
print (a)
id(a)

"""now in functions"""

a = np.round(np.random.random(size=5),3)
print (a)
id(a)

def getmax(x):
    print ("mem address in function", id(x))
    return np.max(x)

getmax(a)

def getmax_after_sinplus1(x):
    print ("mem address in function before op", id(x))
    x = np.sin(x+1)
    print ("mem address in function after op", id(x))
    return np.max(x)

getmax_after_sinplus1(a)

print (a)

"""however, the following implementation changes `a` **outside** the function"""

def getmax_after_sinplus1(x):
    print ("mem address in function before op", id(x))
    x += 1
    print ("mem address in function after +1", id(x))
    x = np.sin(x)
    print ("mem address in function after sin", id(x))
    return np.max(x)

getmax_after_sinplus1(a)

print (a)

"""Expressions like `+1` are **faster** and use **less memory** but may have side effects. We will see this in `pandas`

## Matplotlib

plotting naturally exploits vectorization

see https://matplotlib.org/gallery.html for exameples and guides.
"""

x = np.linspace(-1,1,20)
x

x**2

plt.plot(x, x**2, label="$x^2$")
# cosmetics
plt.grid();
plt.title("plotting function")
plt.xlabel("$x$")
plt.ylabel("$x^2$")
plt.legend();

"""all plotting happens in the same figure until we create a new one"""

plt.plot(x, x**2, color="red", label="$x^2$")

x2_with_noise = x**2 + np.random.normal(size=x.shape)*.1

xdense = np.linspace(np.min(x), np.max(x), 200)
xdense2_with_noise = xdense**2 + np.random.normal(size=xdense.shape)*.1


plt.scatter(x, x**2, s=50, color="red", alpha=.5, label="actual data points")
plt.scatter(x, x2_with_noise, s=50, color="black", label="data with noise")
plt.scatter(xdense, xdense2_with_noise, s=5, color="blue", alpha=.5, label="data with noise")
plt.grid();

plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

"""some statistical plots"""

x1 = np.random.normal(loc=0, scale=1, size=10000)
x2 = np.random.normal(loc=2, scale=2, size=10000)
plt.hist(x1, bins=30, alpha=.5, density=True, label="x1");
plt.hist(x2, bins=30, alpha=.5, density=True, label="x2");
plt.grid(); plt.legend();

plt.boxplot([x1, x2]);
plt.grid();
plt.xticks(range(1,3), ["x1", "x2"]);

